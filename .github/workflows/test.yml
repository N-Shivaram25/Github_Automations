name: Solution Testing Workflow

on:
  push:
    paths:
      - 'solutions/**'
  pull_request:
    paths:
      - 'solutions/**'

jobs:
  check-single-file-change:
    runs-on: ubuntu-latest
    outputs:
      changed_file: ${{ steps.check-files.outputs.changed_file }}
      language: ${{ steps.detect-language.outputs.language }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Check for single file change
        id: check-files
        run: |
          if [ "${{ github.event_name }}" == "push" ]; then
            CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.event.after }} | grep -E "^solutions/")
          else
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | grep -E "^solutions/")
          fi
          
          echo "Changed solution files:"
          echo "$CHANGED_FILES"
          
          # Count how many solution files were changed
          CHANGED_COUNT=$(echo "$CHANGED_FILES" | grep -v "^$" | wc -l)
          
          if [ "$CHANGED_COUNT" -gt 1 ]; then
            echo "::error::Multiple solution files were changed in this commit. Please modify only one solution file at a time."
            exit 1
          elif [ "$CHANGED_COUNT" -eq 0 ]; then
            echo "No solution files were changed."
            exit 0
          else
            echo "changed_file=$CHANGED_FILES" >> $GITHUB_OUTPUT
          fi

      - name: Detect programming language
        id: detect-language
        if: steps.check-files.outputs.changed_file != ''
        run: |
          FILE="${{ steps.check-files.outputs.changed_file }}"
          if [[ "$FILE" == *.py ]]; then
            echo "language=python" >> $GITHUB_OUTPUT
          elif [[ "$FILE" == *.c ]]; then
            echo "language=c" >> $GITHUB_OUTPUT
          elif [[ "$FILE" == *.cpp ]]; then
            echo "language=cpp" >> $GITHUB_OUTPUT
          elif [[ "$FILE" == *.java ]]; then
            echo "language=java" >> $GITHUB_OUTPUT
          else
            echo "::error::Unsupported file type: $FILE"
            exit 1
          fi

  run-tests:
    needs: check-single-file-change
    if: needs.check-single-file-change.outputs.changed_file != ''
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Check solution for empty or incomplete code
        run: |
          FILE="${{ needs.check-single-file-change.outputs.changed_file }}"
          # Check if file is empty or contains only comments/whitespace
          if [ ! -s "$FILE" ] || [[ $(grep -v -E "^\s*(//|#|/\*|\*|$)" "$FILE" | wc -l) -eq 0 ]]; then
            echo "::error::Solution file is empty or contains only comments/whitespace."
            exit 1
          fi
          
          # If the file is a Python file, check for common patterns that indicate incomplete code
          if [[ "$FILE" == *.py ]]; then
            # Only flag standalone pass statements
            if grep -q "^[[:space:]]*pass[[:space:]]*$" "$FILE" || grep -q "^[[:space:]]*# TODO" "$FILE"; then
              echo "::error::Solution appears to be incomplete (contains placeholder code)."
              exit 1
            fi
          fi
          
          # If the file is a C/C++ file, check for function stubs
          if [[ "$FILE" == *.cpp ]] || [[ "$FILE" == *.c ]]; then
            if grep -q "// TODO" "$FILE"; then
              echo "::error::Solution appears to be incomplete (contains placeholder code)."
              exit 1
            fi
            
            # Check for empty function bodies
            if grep -q "{[[:space:]]*}" "$FILE"; then
              echo "::error::Solution appears to be incomplete (contains empty function bodies)."
              exit 1
            fi
          fi
          
          # If the file is a Java file, check for method stubs
          if [[ "$FILE" == *.java ]]; then
            if grep -q "// TODO" "$FILE" || grep -q "throw new UnsupportedOperationException" "$FILE"; then
              echo "::error::Solution appears to be incomplete (contains placeholder code)."
              exit 1
            fi
            
            # Check for empty method bodies
            if grep -q "{[[:space:]]*}" "$FILE"; then
              echo "::error::Solution appears to be incomplete (contains empty method bodies)."
              exit 1
            fi
          fi

      # Setup for Python
      - name: Set up Python
        if: needs.check-single-file-change.outputs.language == 'python'
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Install Python dependencies
        if: needs.check-single-file-change.outputs.language == 'python'
        run: |
          python -m pip install --upgrade pip
          pip install pytest numpy pandas
          # Add more dependencies as needed for specific problems

      # Setup for C/C++
      - name: Set up C/C++ environment
        if: needs.check-single-file-change.outputs.language == 'c' || needs.check-single-file-change.outputs.language == 'cpp'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake

      # Setup for Java
      - name: Set up JDK
        if: needs.check-single-file-change.outputs.language == 'java'
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      # Test execution for Python - simplified approach for clearer debugging
      - name: Run Python tests
        if: needs.check-single-file-change.outputs.language == 'python'
        run: |
          echo "Running Python tests for ${{ needs.check-single-file-change.outputs.changed_file }}"
          
          # Create __init__.py files to ensure proper package structure
          touch solutions/__init__.py
          touch tests/__init__.py
          
          # Create a test runner file
          cat > run_python_tests.py << 'EOF'
import unittest
import sys
import os

# Add the root directory to the Python path
sys.path.insert(0, os.path.abspath('.'))

try:
    # Print debug info
    print("Python path:", sys.path)
    print("Current directory:", os.getcwd())
    print("Directory contents:", os.listdir('.'))
    print("Solutions directory contents:", os.listdir('solutions'))
    print("Tests directory contents:", os.listdir('tests'))
    
    # Try importing from solution
    print("Attempting to import from solution module...")
    from solution import Solution, ListNode
    print("Successfully imported Solution classes!")
    
    # Load test cases
    print("Loading test cases...")
    sys.path.insert(0, 'tests')
    from test import TestRemoveElements
    print("Test cases loaded successfully!")
    
    # Run tests
    print("Running tests...")
    test_suite = unittest.TestLoader().loadTestsFromTestCase(TestRemoveElements)
    test_result = unittest.TextTestRunner(verbosity=2).run(test_suite)
    
    # Check test results
    if not test_result.wasSuccessful():
        print("Some tests failed!")
        sys.exit(1)
    else:
        print("All tests passed!")
        
except Exception as e:
    print(f"Error occurred: {e}")
    import traceback
    traceback.print_exc()
    sys.exit(1)
EOF
          
          # Copy solution.py to root directory for easier imports
          cp solutions/solution.py .
          
          # Run the test runner
          python run_python_tests.py

      # Test execution for C
      - name: Run C tests
        if: needs.check-single-file-change.outputs.language == 'c'
        run: |
          echo "Running C tests for ${{ needs.check-single-file-change.outputs.changed_file }}"
          
          # Compile the test file with the solution
          gcc -o test_program tests/test.c ${{ needs.check-single-file-change.outputs.changed_file }} -lm
          
          # Run the tests
          ./test_program
        continue-on-error: false

      # Test execution for C++
      - name: Run C++ tests
        if: needs.check-single-file-change.outputs.language == 'cpp'
        run: |
          echo "Running C++ tests for ${{ needs.check-single-file-change.outputs.changed_file }}"
          
          # Compile the solution and test files
          g++ -std=c++17 -c ${{ needs.check-single-file-change.outputs.changed_file }} -o solution.o
          g++ -std=c++17 -c tests/test.cpp -o test.o
          g++ -std=c++17 solution.o test.o -o test_program
          
          # Run the tests
          ./test_program
        continue-on-error: false

      # Test execution for Java
      - name: Run Java tests
        if: needs.check-single-file-change.outputs.language == 'java'
        run: |
          echo "Running Java tests for ${{ needs.check-single-file-change.outputs.changed_file }}"
          
          # Create build directory
          mkdir -p build
          
          # Compile Java files
          javac -d build ${{ needs.check-single-file-change.outputs.changed_file }} tests/Test.java
          
          # Run the tests
          cd build && java Test
        continue-on-error: false

      - name: Test Results Summary
        run: |
          echo "All tests have passed successfully for ${{ needs.check-single-file-change.outputs.changed_file }}!"